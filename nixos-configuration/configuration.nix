{ lib, pkgs, ... }:

let
  NixOSRelease = "23.11";
  home-manager = builtins.fetchTarball "https://github.com/nix-community/home-manager/archive/release-${NixOSRelease}.tar.gz";
  prathamsHome = "/home/pratham";
  scriptsDir = "${prathamsHome}/.local/scripts";

  sudoRules = with pkgs; [
    { package = coreutils; command = "sync"; }
    { package = hdparm; command = "hdparm"; }
    { package = nix; command = "nix-collect-garbage"; }
    { package = nixos-rebuild; command = "nixos-rebuild"; }
    { package = nvme-cli; command = "nvme"; }
    { package = systemd; command = "poweroff"; }
    { package = systemd; command = "reboot"; }
    { package = systemd; command = "shutdown"; }
    { package = systemd; command = "systemctl"; }
    { package = util-linux; command = "dmesg"; }
  ];

  mkSudoRule = rule: {
    command = "${rule.package}/bin/${rule.command}";
    options = [ "NOPASSWD" ];
  };

  sudoCommands = map mkSudoRule sudoRules;

  whatIGetForSupportingTheRaspberryPiFoundation = pkgs.writeShellScriptBin "populate-boot-for-raspberry-pi" ''
    set -xe

    if grep 'Raspberry Pi' /proc/device-tree/model > /dev/null; then
        cp "${pkgs.ubootRaspberryPi4_64bit}/u-boot.bin" /boot
        cp -r "${pkgs.raspberrypifw}/share/raspberrypi/boot/"* /boot
        cat << EOF > /boot/config.txt
        enable_uart=1
        avoid_warnings=1
        arm_64bit=1
        kernel=u-boot.bin
        [pi4]
        #hdmi_enable_4kp60=1
        arm_boost=1
    fi
  '';

  OVMFBinName = if pkgs.stdenv.isAarch64 then "AAVMF"
    else (
      if pkgs.stdenv.isx86_64 then "OVMF"
      else ""
    );
in

{
  imports = [
    ./host-specific-configuration.nix # specific to this host
    (import "${home-manager}/nixos") # aye, home-manager
    ./hardware-configuration.nix # generated by 'nixos-generate-config'
  ];

  # {{ packages section }}
  nixpkgs.config.allowUnfree = true; # allow non-FOSS pkgs

  # {{ user configuration }}

  # {{ home-manager configuration }}
  # call the home-manager configuration directly
  # without having to depend on a $HOME/.config/home-manager/{home,flake}.nix
  home-manager.users.pratham = { lib, pkgs, ... }: {
    home.stateVersion = "${NixOSRelease}";


  };



  # {{ configuration options related to Nix and NixOS }}
  nix = {
    gc = {
      automatic = true;
      dates = "*-*-* 23:00:00"; # everyday, at 23:00
      options = "--delete-older-than 14d";
    };

    settings = {
      auto-optimise-store = true;
      experimental-features = [ "nix-command" "flakes" ];
      keep-going = false;
      log-lines = 9999;
      sandbox = true;
      show-trace = true;
      trusted-users = [ "root" "pratham" ];
    };
  };

  system = {
    stateVersion = "${NixOSRelease}"; # release version of NixOS
    # TODO: after adding `ubootRaspberryPi_64bit` to nixpkgs
    # also remove: `scripts/{get-raspi-4-firmware,raspberry-pi-partitions}.sh`
    #build.separateActivationScript = "${whatIGetForSupportingTheRaspberryPiFoundation}/bin/populate-boot-for-raspberry-pi";

  };

  # {{ networking section }}

  # {{ misc }}

  # {{ virtualisation and container settings }}
  virtualisation = {
    oci-containers.backend = "podman";

    libvirtd = {
      enable = true;
      onShutdown = "shutdown";
      allowedBridges = [ "virbr0" ];
      qemu = {
        package = pkgs.qemu_kvm;
        runAsRoot = false; # not sure about this
        swtpm.enable = true;

        ovmf = {
          enable = true;
          packages = [ pkgs.OVMF ];
        };

        verbatimConfig = ''
          user = "pratham"
          group = "pratham"
        '';
      };
    };

    podman = {
      enable = true;
      dockerCompat = true;
      dockerSocket.enable = true;
      networkSocket.openFirewall = true;
      extraPackages = [ pkgs.buildah ];
      defaultNetwork.settings = {
        dns_enabled = true;
      };
      autoPrune = {
        enable = true;
        dates = "weekly";
        flags = [ "--all" ];
      };
    };
  };

  boot = {
    kernelParams = [
      "audit=0"
      "ignore_loglevel"

      "boot.shell_on_fail"

      "fsck.mode=auto"
      "fsck.repair=preen"

      "plymouth.enable=0"
      "rd.plymouth=0"

      "no_console_suspend"
    ];

    supportedFilesystems = [
      "ext4"
      "f2fs"
      "vfat"
      "xfs"
    ];

    kernel.sysctl = {
      ## Z-RAM-Swap
      # Kernel docs: https://docs.kernel.org/admin-guide/sysctl/vm.html
      # Pop!_OS "docs": https://github.com/pop-os/default-settings/pull/163/files
      # Using zramswap, penalty shouldn't be that high, since if you are under
      # high memory pressure, you likely are under high CPU load too
      # at which point, you are performing computations and latency goes moot.
      "vm.swappiness" = 180;
      # Since zramSwap.algorithm is set to 'zstd', it is recommeded to set the
      # 'vm.page-cluster' paramater to '0'.
      "vm.page-cluster" = 0;
      # Ensure that at-least 512MBytes of total memory is free to avoid system freeze.
      # Not sure about the 512MBytes value since Pop!_OS sets it to 0.01% of total memory,
      # which is roughly equal to 3.7MBytes on a 3700MBytes RPi4. The value of 512MBytes
      # also does not leave lee-way for a 512M RPi Zero.
      # A value too LOW  will result in system freeze.
      # A value too HIGH will result in OOM faster.
      "vm.min_free_kbytes"= 512000;
      # Disable 'vm.wwatermark_scale_factoratermark_boost_factor'.
      # https://groups.google.com/g/linux.debian.user/c/YcDYu-jM-to
      "vm.watermark_boost_factor" = 0;
      # Start swapping when 70% of memory is full (30% of memory is left).
      # 3000 is the MAX
      "vm.watermark_scale_factor" = 3000;
      # Increase the number of maximum mmaps a process may have (ZFS).
      # 2147483642 = 1.99-ish GiB
      "vm.max_map_count" = 2147483642;

      # Same as `vm.dirty_ratio` but for background tasks
      "vm.dirty_background_ratio" = 10;
      # After how many centiseconds (1 second = 100 centiseconds) is dirty data
      # committed to the disk
      "vm.dirty_expire_centisecs" = 3000;
      # Percentage of memory allowed to be filled with dirty data until it is
      # committed to the disk
      "vm.dirty_ratio" = 20;
      # Interval between the kernel flusher threads that wake up to write old
      # data to the disk. **Try keeping this less than half of whatever
      # `vm.dirty_expire_centisecs`.**
      # Check every N centisecs if data needs to be committed to the disk or not.
      "vm.dirty_writeback_centisecs" = 1000;

      # The Magic SysRq key is a key combo that allows users connected to the
      # system console of a Linux kernel to perform some low-level commands.
      # Disable it, since we don't need it, and is a potential security concern.
      "kernel.sysrq" = 0;

      ## TCP hardening
      # Prevent bogus ICMP errors from filling up logs.
      "net.ipv4.icmp_ignore_bogus_error_responses" = 1;
      # Reverse path filtering causes the kernel to do source validation of
      # packets received from all interfaces. This can mitigate IP spoofing.
      "net.ipv4.conf.default.rp_filter" = 1;
      "net.ipv4.conf.all.rp_filter" = 1;
      # Do not accept IP source route packets (we're not a router)
      "net.ipv4.conf.all.accept_source_route" = 0;
      "net.ipv6.conf.all.accept_source_route" = 0;
      # Don't send ICMP redirects (again, we're on a router)
      "net.ipv4.conf.all.send_redirects" = 0;
      "net.ipv4.conf.default.send_redirects" = 0;
      # Refuse ICMP redirects (MITM mitigations)
      "net.ipv4.conf.all.accept_redirects" = 0;
      "net.ipv4.conf.default.accept_redirects" = 0;
      "net.ipv4.conf.all.secure_redirects" = 0;
      "net.ipv4.conf.default.secure_redirects" = 0;
      "net.ipv6.conf.all.accept_redirects" = 0;
      "net.ipv6.conf.default.accept_redirects" = 0;
      # Protects against SYN flood attacks
      "net.ipv4.tcp_syncookies" = 1;
      # Incomplete protection again TIME-WAIT assassination
      "net.ipv4.tcp_rfc1337" = 1;

      ## TCP optimization
      # TCP Fast Open is a TCP extension that reduces network latency by packing
      # data in the senderâ€™s initial TCP SYN. Setting 3 = enable TCP Fast Open for
      # both incoming and outgoing connections:
      "net.ipv4.tcp_fastopen" = 3;
      # Bufferbloat mitigations + slight improvement in throughput & latency
      "net.ipv4.tcp_congestion_control" = "bbr";
      "net.core.default_qdisc" = "cake";

      ## Allow rootless containers to get pinged and/or ping each other
      "net.ipv4.ping_group_range" = "0 165536";
    };

    loader = {
      timeout = 5;
      systemd-boot = {
        enable = true;
        editor = false;
      };
    };
  };

  hardware.enableRedistributableFirmware = true;
}
